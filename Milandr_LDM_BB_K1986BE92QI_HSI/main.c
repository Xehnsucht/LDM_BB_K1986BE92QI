#include "MDR32Fx.h"
#include "core_cm3.h"
#include "MDR32F9Qx_config.h"
#include "system_MDR32F9Qx.h"
#include "MDR32F9Qx_rst_clk.h"
#include "MDR32F9Qx_port.h"
#include "MDR32F9Qx_port.h"             // Keil::Drivers:PORT
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
//===========================================================================================================================//
//--------------------------------Тестовая программ(1) для HSI с вкл\выкл  PLL и его коэф. умножения = 0..16 ----------------//
// 1)Переключение светодиода LED, используя SysTick с числами Фибоначчи т.е каждый раз увеличиваем значение для Delay_dec;    
// 2)void PerClkConfig(int val)Функция настройки тактирования периферии МК (0 - выкл всей периферии; 1- вкл. всю периферию);																									     
// 3)Вычисление матриц с случайным заполнением и заполнением числами Фибоначчи
// 		для целочисленных int matrix(int q) и с плавающей запятой матрицfloat fmatrix( int q);
// 4)Простая реализация Хеш-функции для контроля конечных сумм матриц unsigned int hash ( int key).																											 
//---------------------------------------------------------------------------------------------------------------------------//
//===========================================================================================================================//

/*
	Спецификация микросхем серии 1986ВЕ9ху, К1986ВЕ9ху, К1986ВЕ9хуК,
	К1986ВЕ92QI, К1986ВЕ92QC, 1986ВЕ91Н4, К1986ВЕ91Н4, 1986ВЕ94Н4, К1986ВЕ94Н4
	(datasheet стр.171)
|-----------|-------------------------|-----------------------------------------------------------|
| № бита    | Функциональное имя бита | Расшифровка функционального имени бита, краткое описание  |
|						|		 	              			|	назначения и принимаемых значений										  		|
|-----------|-------------------------|-----------------------------------------------------------|
| Бит 0..1  |		CPU 			  					| Биты выбора источника для CPU_C1:						  						|
|						|		C1				  					|	00 – HSI												  												|
|						|		SEL[0..1]		  				|	01 – HSI/2												  											|
|						|						  						|	10 – HSE												  												|
|						|						  						|	11 – HSE/2												  											|
|-----------|-------------------------|-----------------------------------------------------------|
|Бит 2	 		|	CPU					 					  | Биты выбора источника для CPU_C2: 						  					|		
|						|	C2 					  					|	0 – CPU_C1												  											|	
|						|	SEL 				  					|	1 – PLLCPUo												  											|
|-----------|-------------------------|-----------------------------------------------------------|
| Бит 3    	| 				-		  					| 	Зарезервировано										  										| 
|-----------|-------------------------|-----------------------------------------------------------|
| Бит 7…4 	|						  						| Биты выбора делителя для CPU_C3:						  						|
|						|						  						| 	0xxx – CPU_C3 = CPU_C2								  								|	
|						|						  						|	1000 - CPU_C3 = CPU_C2 / 2								  							|
|						|						  						|	1001 - CPU_C3 = CPU_C2 / 4								  							|
|						|						  						|	1010 - CPU_C3 = CPU_C2 / 8								  							|
|						|						  						|	…														  														|
|						|						  						|	1111 - CPU_C3 = CPU_C2 / 256							  							|
|-----------|-------------------------|-----------------------------------------------------------|
|Бит 9…8 		|		HCLK      		  			| Биты выбора источника для HCLK:							  						|
|						|		SEL[1:0]		  				|	00 – HSI												  												|
|						|					 	  						|	01 – CPU_C3												  											|
|						|						  						|	10 – LSE												  												|
|						|						  						|	11 – LSI												  												|
|-----------|-------------------------|-----------------------------------------------------------|
|Бит31-10		| 				-		  					| 	Зарезервировано	     								  									| 								
|-----------|-------------------------|-----------------------------------------------------------|	
	

*/
#define LED PORT_Pin_2 // определение LED, как PORT_Pin 2 для светодиода C
#define BUT PORT_Pin_5 // определение BUT, как PORT_Pin 5 для кнопки D

static PORT_InitTypeDef PortInit; // структура для инициализации портов
int refibonacci(int n); //прототип функции для вычисления чисел Фибоначчи
volatile uint32_t Delay_dec = 0; // переменная для прерываний
/*  
  (datasheet стр.158)
  Бит 31..12 ---------------- Зарезервировано 
  Бит 11..8  PLL CPU MUL[3:0] Коэффициент умножения для CPU PLL: PLLCPUo = PLLCPUi x (PLLCPUMUL+1) 
  Маски для определение значение умножения для регистра MDR_RST_CLK->PLL_CONTROl (x<<8), где (x<<8) заменяем на необходимую маску для PLL
*/
// 														коэф умножения PLL
#define RST_CLK_CPU_PLLm0                     (-1<<8)	//умножить частоту на 0  
#define RST_CLK_CPU_PLLm1                     (0<<8)	//умножить частоту на 1
#define RST_CLK_CPU_PLLm2                     (1<<8)	//умножить частоту на 2
#define RST_CLK_CPU_PLLm3                     (2<<8)	//умножить частоту на 3
#define RST_CLK_CPU_PLLm4                     (3<<8)	//умножить частоту на 4
#define RST_CLK_CPU_PLLm5                     (4<<8)	//умножить частоту на 5
#define RST_CLK_CPU_PLLm6                     (5<<8)	//умножить частоту на 6
#define RST_CLK_CPU_PLLm7                     (6<<8)	//умножить частоту на 7
#define RST_CLK_CPU_PLLm8                     (7<<8)	//умножить частоту на 8
#define RST_CLK_CPU_PLLm9                     (8<<8)	//умножить частоту на 9
#define RST_CLK_CPU_PLLm10                    (9<<8)	//умножить частоту на 10
#define RST_CLK_CPU_PLLm11                    (10<<8)	//умножить частоту на 11
#define RST_CLK_CPU_PLLm12                    (11<<8)	//умножить частоту на 12
#define RST_CLK_CPU_PLLm13                    (12<<8)	//умножить частоту на 13
#define RST_CLK_CPU_PLLm14                    (13<<8)	//умножить частоту на 14
#define RST_CLK_CPU_PLLm15                    (14<<8)	//умножить частоту на 15
#define RST_CLK_CPU_PLLm16                    (15<<8)	//умножить частоту на 16
/*
	(datasheet стр.172)
	Регистры блока батарейного домена
	MDR_BKP->REG_0E
	Бит 5...3 SelectRI[2:0] Выбор дополнительной стабилизирующей нагрузки
							 для встроенного регулятора напряжения DUcc:

	Бит 2...0 LOW[2:0]	 	Выбор режима работы встроенного регулятора напряжения DUCC. 
							 Значение LOW должно совпадать со значением SelectRI и 
							 выставляться в зависимости от тактовой частоты микроконтроллер
	маска REG_0E1_vX для записи в SelectRI[2:0]
	маска REG_0E0_vX для запис в LOW[2:0]
	где х диапазон 
	х=0  Частота до 10 МГц,   значение PLL=[0..1];
	x=1  Частота до 40 МГц,   значение PLL=[2..4];
	x=2  Частота до 80МГц,	  значение PLL=[5..9];
	x=3	 Частота более 80МГц, значение PLL=[10..16].
*/
// Маски для выбора режимы работы встроенного регулятора от частоты
// Частота до 10 МГц, PLL=[0..1]
#define REG_0E0_v0														(0 << 0)
#define REG_0E1_v0														(0 << 3)
// Частота до 40 МГц  PLL=[2..4]
#define REG_0E0_v1														(5 << 0)
#define REG_0E1_v1														(5 << 3)
// Частота до 80МГц	  PLL=[5..9]
#define REG_0E0_v2														(6 << 0)
#define REG_0E1_v2														(6 << 3)
// Частота более 80МГц PLL=[10..16]
#define REG_0E0_v3														(7 << 0)
#define REG_0E1_v3														(7 << 3)


/* Hash-функция */
#define HASH_SIZE 100000 // размер Хеш`а
unsigned int hash ( int key)
	{ //простая функция хеширования значения
		unsigned long int value =0;	// Хеш
		unsigned int i=0;
		unsigned int key_len =key;	//входное значение 
	for (; i < key_len; ++i){
	// 37 это P, один из методов нахождения  hash(S)=S[0]+S[1]*P+S[2]*P^2+S[3]*P^3+...+S[N]*P^N
		value =value *37+key;
	}
	value=value % HASH_SIZE;//для избегания коллизий(что бы Хеш не был одинаковым)
	return value;
}
/*Функция вычисления чисел Фибоначчи*/
int refibonacci(int n)
{ 
  int first = 0, second= 1, next, count;
   for (count = 0; count < n; count++)
  {
    if (count <= 1)
      next = count;
    else
    {
      next = first+ second;
      first = second;
      second = next;
    }
  }
   return next;
}
/*Функция вычиление целочисленной матрицы*/
int matrix(int q)
{ 
//	Для заполнения случайными значениями
	/*	srand(time(NULL));// Функция srand выполняет инициализацию генератора случайных чисел rand.
	 	 заменить refibonacci(i) на rand()%10, и наоборот;
	*/
//инициализация переменных
	 int N=q;
	 int i; 
	 int S=0; // переменная для храенния суммы всех элементов матрицы
	 int j;
//используя функцию malloc выделем место в памяти для матриц, двойной указатель указывает на массив и элементы в нем
	 int **A=(int**)malloc(N* sizeof(int*));
	 int **B=(int**)malloc(N* sizeof(int*));
	 for (i = 0; i < N; i++){
// выделение памяти для элементов 
				A[i] = (int*)malloc(N * sizeof(int));
				B[i] = (int*)malloc(N * sizeof(int));
		}
//заполнение матриц
	for (i = 0; i < N; i++)
		for (j = 0; j < N; j++){
			A[i][j] = refibonacci(i+1);
			B[i][j] = refibonacci(j+2);
		}
//расчет суммы всех элементов матрицы
		for (i=0; i<N; i++)
					for ( j = 0; j < N; j++)
									S+=A[i][j]+B[i][j];
		// отчистка памяти 
		for (int i = 0; i < N; ++i){
							free(A[i]);
							free(B[i]);
						}        
		free (A);
		free (B);
	// возвращаем сумму всеъ элеметнов матриц
	return S;
} 
/*Функция вычиления матриц с плавающей запятой, можно убрать использовалась для тестов*/
float fmatrix( int q)
{
	//	Для заполнения случайными значениями
	//	srand(time(NULL));
	/* Функция srand выполняет инициализацию генератора случайных чисел rand.
	 	Для заполнения чиселами Фибоначчи заменить rand()%10 на refibonacci(i) и наоборот;
	*/
	// инициализация перменных 
        int N=q;// размер матриц [N][N];
		int i;
		int j;
		float sum=0;// для суммы всех элементов матриц
		float sum1=0;
	//выделение памяти для матриц, так же как и с целочиленными
		float **A = (float**)malloc(N * sizeof(int*)); // в А адрес ячейки, в которой находиться адрес  числа 
        float **B = (float**)malloc(N * sizeof(int*)); // в В адрес ячейки, в которой находиться адрес 	числа
		// деление для уменьшения числа
		float b =10000000000;
		// выделение памяти для элементов 
        for (i = 0; i < N; i++){
            A[i] = (float*)malloc(N * sizeof(int));
            B[i] = (float*)malloc(N * sizeof(int));
        }
    // заполнение матриц
    for (i = 0; i < N; i++){
        for (j = 0; j < N; j++){
            A[i][j] = (rand()/b);
            B[i][j] = (rand()/b);
        }
    }
//  Сумма всех чисел матрицы А и B
   for ( i = 0; i < N; i++){
        for ( j = 0; j < N; j++){
            sum+= A[i][j]+B[i][j];
        }
    }
    sum1=sum;
    // отчистка памяти
	for (i = 0; i < N; i++){
            free(A[i]);
            free(B[i]);
        }
        free(A);
        free(B);
	return sum1;
}

void SysTick_init(void){//Системная задержка, полхой варинат т.к простой МК
	SysTick->LOAD |= (8000000/1000)-1;// Устанавливает стартовое значение, загружаемое в регистр VAL.
	/*	(datasheet стр.139-141)
	По умолчанию она равна 8 Мгц = 8000000 тактов в секунду. 
	В одной секунде тысяча миллисекунд => 8000000(количество тактов в секунду)/
	/1000(количество миллисекунд в секунде) = количество тактов в одной миллисекунде.
	
	SysTick->CTRL
	
	Бит 2: CLKSOURCE Указывает источник синхросигнала: 
			0-LSI;
			1-HCLK.
	Бит 1: TCKINT Разрешает запрос на прерывание от  системного таймера:
			0 - таймер досчитает до нуля и  прерывание не возникнет; 
			1 - таймер досчитывает до нуля и возникает запрос на прерывание.
	Бит 0: ENABLE Разрешает работу таймера: 
			0 - работа таймера запрещена; 
			1 - работа таймера разрешена. 

*/
	SysTick->CTRL |= (1<<2)|(1<<1)|(1<<0);//Регистр CTRL разрешает основные функции системного таймера.
	//              CLKSOURCE=1 | TICKINT=1 |  ENABLE=1
}
void SysTick_Handler (void){// находиться в startup_MDR32F9Qx.s
	if (Delay_dec) Delay_dec--;// Обратный отчет
}

void Delay_ms (uint32_t Delay_ms_Data){
	Delay_dec = Delay_ms_Data;
	while (Delay_dec) {};
}

void HSI_init ( void ){
	// иницализация HSI,
	// для отключения PLL: закомментить первые три строчки. Формула для вычисления коэф. умножения = (RST_CLK_CPU_PLLmX+1)=X+1
  // подача частоты на блок PLL (datasheet стр.160)
     MDR_RST_CLK->CPU_CLOCK = ((0 << 0));
  // Настройка PLL(datasheet стр.158)
     MDR_RST_CLK->PLL_CONTROL = ((1 << 2) | (8 << 8));//вкл. PLL  | коэф. умножения = (RST_CLK_CPU_PLLmX+1)=X+1
     while ((MDR_RST_CLK->CLOCK_STATUS & 0x02) != 0x02);// ждем когда PLL выйдет в раб. режим
	// Настройка частоты процессора
     MDR_RST_CLK->CPU_CLOCK = ((0 << 0)		//источник для CPU_C1
                             | (1 << 2)		//источник для CPU_C2
                             | (0 << 4)		//предделитель для CPU_C3
                             | (1 << 8));	//источник для HCLK->CPU_C3

     MDR_BKP->REG_0E |= (REG_0E0_v3 << 0); //режим встроенного регулятора напряжения DUcc
     MDR_BKP->REG_0E |= (REG_0E0_v3 << 3); //выбор доп.стабилизирующей нагрузки
	}// HSI_init();

void LED_init(void){
	//(datasheet стр.184-186)
	
	//иницализация LED
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTC, ENABLE);//вкл тактирование порта С
	//Структура для настройки портаC в режим записи
	PortInit.PORT_OE = PORT_OE_OUT; 				// выход
	PortInit.PORT_FUNC = PORT_FUNC_PORT; 		// функция порта
	PortInit.PORT_MODE = PORT_MODE_DIGITAL; // цифровой выход
	PortInit.PORT_SPEED = PORT_SPEED_SLOW; 	// выбор медленного режима
	PortInit.PORT_Pin = (LED); 							// выбор пина с светодиодом
	PORT_Init(MDR_PORTC, &PortInit); 				// инициализация порта
	PORT_ResetBits(MDR_PORTC, LED); 				// выкл LED
		
	PORT_Init(MDR_PORTC, &PortInit); 				
	
}// LED_init();

void BUT_init(void){//можно убрать использовалась для тестов
	//(datasheet стр.184-186)
	RST_CLK_PCLKcmd(RST_CLK_PCLK_PORTD, ENABLE);//вкл тактирования порта D
	//Структура для настройки порта D в режим чтения 
	PortInit.PORT_OE = PORT_OE_IN; 						// вход
	PortInit.PORT_FUNC = PORT_FUNC_PORT; 			// функция порта
	PortInit.PORT_MODE = PORT_MODE_DIGITAL; 	// цифровой вход
	PortInit.PORT_SPEED = PORT_SPEED_SLOW;  	// выбор медленного режима
	PortInit.PORT_Pin = (BUT); 								// выбор пина с кнопкой
	
	PORT_Init(MDR_PORTD, &PortInit); 
}// BUT_init();

/*	
		Функция управления тактированием блоков периферии МК.	
		Спецификация микросхем серии 1986ВЕ9ху, К1986ВЕ9ху, К1986ВЕ9хуК,К1986ВЕ92QI, К1986ВЕ92QC, 
		1986ВЕ91Н4, К1986ВЕ91Н4, 1986ВЕ94Н4, К1986ВЕ94Н4 (datasheet стр.175) 
		Сигналы тактовой частоты MDR_RST_CLK (стр.165)
*/
void PerClkConfig(int val){
	//Функция настройки тактирования периферии МК (0 - выкл всей периферии; 1- вкл. всю периферию)
	MDR_RST_CLK->PER_CLOCK |= (val << 5) | /*DMA*/ 
														(val << 6) /*UART1*/ |
														(val << 7) /*UART2*/ |
														(val << 8) /*SPI1*/  |
														/*PCLK[9] – зарезервировано*/
														(val << 10) /*I2C1*/ |
														(val << 11) /*POWER*/|
														(val << 12) /*WWDT*/ |
														//(val << 13) /*IWDT*/ 
														(val << 14) /*TIMER1*/|
														(val << 15) /*TIMER2*/|
														(val << 16) /*TIMER3*/|
														(val << 17) /*ADC*/   |
														(val << 18) /*DAC*/   |
														(val << 19) /*COMP*/  |
														(val << 20) /*SPI2*/  |
														(val << 21) /*PORTA*/ |
														(val << 22) /*PORTB*/ |
														(val << 23) /*PORTC*/ |
														(val << 24) /*PORTD*/ |
														(val << 25) /*PORTE*/ |
														/*PCLK[26] – зарезервировано*/
														(val << 27) /*BKP*/   |
														/*PCLK[28] – зарезервировано*/
														(val << 29) /*PORTF*/ |
														(val << 30); /*EXT_BUS_CNTRL*/ 
														/*PCLK[31] – зарезервировано*/
} // void PerClkConfig

int main(){
	// Вызвов функций для работы МК
  PerClkConfig(1); // 1 для вкл всей периферии, 0 для откл всей периферии
	SysTick_init();  //инициализация задержки
	HSI_init(); 		 //инициализация ядра (тактирование от внутренноге источника HSI)
	LED_init(); 		 //инициализация светодиода
	BUT_init(); 		 //инициализация кнопки, можно убрать использовалась для тестов
	
	// Пауза для тестов, можно убрать
				PORT_SetBits(MDR_PORTC, LED);  //вкл
				Delay_ms(1000);       				 // 1 сек, горит	
				PORT_ResetBits(MDR_PORTC, LED);//вкыкл


	for(;;){ // главный цикл программы
		
			//Хеш-функция
			int key=hash(matrix(5)); 	//Переменная для хранения Хеш`а суммы всех элементов матриц 5х5
			int key1=hash(matrix(6)); //Переменная для хранения Хеш`а суммы всех элементов матриц 6х6
			PORT_SetBits(MDR_PORTC,LED); // для тестов, можно убрать
			
			float Fint=fmatrix(10); // переменная для храения суммы всех элментов float-матрицы
			int Sint=matrix(10); // переменная для храения суммы всех элментов int-матрицы

			if (key != key1){ // условие для проверки результатов вычислений 
				char str[80];
				sprintf (str, "%s %d %d", "key != key1", key, key1);
			}
			else{
				char str[80];
				sprintf(str, "%s %f %d","Суммы всех элементов матриц",Fint, Sint);
			}

	}//end for
}//end main

/* Тест, для отображения того, как с увеличением частоты МК растет скорость переключения при увеличении задержки			
// мигание светодиодом для 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610... с каждой итерацией время вкл/выкл увеличивается 
			for (int i=0; i<15; i++){
			int q=refibonacci(i);
				PORT_SetBits(MDR_PORTC, LED);//вкл
			//	Delay_ms(q);	//задержка for(;q>0;q--)
				PORT_ResetBits(MDR_PORTC, LED);//вкыкл
			//	Delay_ms(q);	//задержка for(;q>0;q--)
			}
*/
